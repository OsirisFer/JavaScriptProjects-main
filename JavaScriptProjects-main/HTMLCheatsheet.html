<!DOCTYPE html>
<html>
	<!-- Metadatos -->
<head>
	<meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Prueba de RIA</title>
    <link rel="stylesheet" type="text/css" href="CheatSheetCss.css">
    <script src="PruebaPrueba.js"></script>
</head>
<body>


    <div id="contenido-paginado">
        <div class="pagina" id="pagina1">
        <h1>JS CHEATSHEET</h1>
        <p>
            var declarada dentro de una función es local a esa función, por lo que no puede ser accedidas desde fuera de ella<br>
            var declarada fuera de una función son globales, por lo que puede ser accedida desde cualquier parte del código<br>
            let y const si se declaran en un bloque de código, solo pueden ser accedidas dentro de ese bloque (if, for, while, etc)<br><br>
            Hoisting lo que hace es que las variables y constantes suben al inicio del código, entonces existen para el compilador pero<br>
            pero no con su valor asignado, por lo que si se intenta acceder a ellas antes de ser declaradas, se obtendrá un valor undefined<br>
            <code>console.log(x);</code> // Output: <code>undefined</code><br>
            <code>var x = 5;</code><br>
            <code>console.log(x);</code> // Output: <code>5</code><br><br>
            Usar camelCase para nombrar variables y constantes ej: hoistedVariable son case-sensitive asó que hoistedvariable no es lo mismo<br>
        </p>
        <h2>Tipos de Datos en JavaScript</h2>
    <ul>
        <li>Number: Representa enteros y números de punto flotante. Ejemplo: <code><strong>let num = 10;</strong></code></li>
        <li>String: Representa texto. Ejemplo: <code><strong>let texto = "Hola";</strong></code></li>
        <li>Boolean: Representa valores lógicos verdadero/falso. Ejemplo: <code><strong>let esVerdadero = true;</strong></code></li>
        <li>Undefined: guarda el valor undefined. Ejemplo: <code><strong>let indefinido;</strong></code></li>
        <li>Null: guarda el valor null. Ejemplo: <code><strong>let nulo = null;</strong></code></li>
        <li>Object: Representa un objeto. Ejemplo: <code><strong>let persona = { nombre: "Juan", edad: 30 };</strong></code></li>
        <li>Symbol:  Introducido en ES6, representa un identificador único e inmutable. Se utiliza para crear propiedades de objetos que son únicas y no colisionan con otras propiedades.. Ejemplo: <code><strong>const simboloId = Symbol('id');</strong></code></li>
        <li>BigInt: Representa números enteros grandes. Ejemplo: <code><strong>let bigNum = 9007199254740991n;</strong></code></li>
    </ul>
    <h2>Creación de objetos:</h2>
    <p>
        <code>
            let persona = {
                nombre: "Juan",
                edad: 30,
                casado: false
            };
        </code>
    </p>
    <p>Un objeto en JavaScript es una colección de pares clave-valor. En este ejemplo, se crea un objeto llamado <code>persona</code> con tres propiedades: <code>nombre</code>, <code>edad</code> y <code>casado</code>.</p>
    <h2>Acceso a las propiedades:</h2>
    <p>
        <code>
            console.log(persona.nombre); // Juan
            <br>
            console.log(persona['edad']); // 30
        </code>
    </p>
    <p>Las propiedades de un objeto se pueden acceder utilizando la notación de punto o la notación de corchetes.</p>
    <h2>Métodos de los objetos:</h2>
    <p>
        <code>
            let persona = {
                nombre: "Juan",
                edad: 30,
                casado: false,
                saludar: function() {
                    console.log("Hola, mi nombre es " + this.nombre);
                }
            };
            <br>
            persona.saludar(); // Hola, mi nombre es Juan
        </code>
    </p>
    <p>Los objetos en JavaScript pueden contener métodos, que son funciones asociadas al objeto. En este ejemplo, <code>saludar</code> es un método de <code>persona</code> que imprime un saludo.</p>
    <h2>Herencia de objetos:</h2>
    <p>
        <code>
            function Animal(nombre) {
                this.nombre = nombre;
            }
            Animal.prototype.saludar = function() {
                console.log("Hola, soy un " + this.nombre);
            };
            <br>
            let perro = new Animal("Perro");
            <br>
            perro.saludar(); // Hola, soy un Perro
        </code>
    </p>
    <p>Los objetos en JavaScript pueden heredar propiedades y métodos de otros objetos a través del prototipo. En este ejemplo, se define un constructor <code>Animal</code> con un método <code>saludar</code> que es heredado por el objeto <code>perro</code>.
        Cuando intentas acceder a una propiedad de un objeto, JavaScript primero busca esa propiedad en el objeto mismo. Si no la encuentra, busca en el prototipo del objeto y luego en el prototipo del prototipo, y así sucesivamente hasta llegar al prototipo null.
    <br> Ejemplo cuando hago <code>Animal.prototype.nombreAnimal = function() {
        console.log("Hola, soy " + this.nombreAnimal);
    };</code><br>
        Lo que hago es cargarle al prototipo al animal el metodo no al objeto animal directamente. Ahorrando memoria porque evito duplicar metodos por cada instancia de animal. </p>
        <h2>Objetos integrados en JavaScript</h2>

    <ul>
        <li><strong>Object:</strong> El objeto base de JavaScript que tiene métodos y propiedades comunes a todos los objetos.
            <code>let persona = { nombre: 'Juan', edad: 30 };</code>
        </li>
        <li><strong>Array:</strong> Utilizado para almacenar colecciones de elementos en una secuencia indexada.
            <code>let numeros = [1, 2, 3, 4, 5];</code>
        </li>
        <li><strong>String:</strong> Utilizado para manipular cadenas de texto.
            <code>let mensaje = 'Hola, mundo!';</code>
        </li>
        <li><strong>Number:</strong> Utilizado para valores numéricos y operaciones matemáticas.
            <code>let edad = 30;</code>
        </li>
        <li><strong>Boolean:</strong> Representa un valor lógico verdadero o falso.
            <code>let esMayor = true;</code>
        </li>
        <li><strong>Function:</strong> Utilizado para definir funciones.
            <code>function saludar(nombre) { console.log('Hola, ' + nombre); }</code>
        </li>
        <li><strong>Date:</strong> Utilizado para trabajar con fechas y horas.
            <code>let fecha = new Date();</code>
        </li>
        <li><strong>RegExp:</strong> Utilizado para trabajar con expresiones regulares.
            <code>let expresionRegular = /[a-z]+/;</code>
        </li>
        <li><strong>Error:</strong> Utilizado para representar errores en tiempo de ejecución.
            <code>throw new Error('Este es un error personalizado');</code>
        </li>
        <li><strong>Math:</strong> Proporciona métodos y constantes matemáticas útiles.
            <code>let raizCuadrada = Math.sqrt(16);</code>
        </li>
        <li><strong>JSON:</strong> Utilizado para trabajar con el formato de intercambio de datos JSON.
            <code>let personaJSON = '{"nombre": "Juan", "edad": 30}';</code>;<br>
            Puedes convertir un objeto JavaScript a una cadena JSON utilizando el método JSON.stringify():
            <code>persona = { nombre: "Juan", edad: 30 };<br>
            let personaJSON = JSON.stringify(persona);<br>
            console.log(personaJSON); // '{"nombre":"Juan","edad":30}'</code> 
        </li>
    </ul> 
    <h2>Typeof</h2>
    <p>typeof es un operador en JavaScript que se utiliza para obtener el tipo de datos de una variable o expresión. <code>let x = 10;<br>
        console.log(typeof x); // "number"</code></p>
    
        <h1>Typecasting en JavaScript</h1>

        <h2>Conversión implícita</h2>
        <p>JavaScript realiza conversiones implícitas de tipos cuando se realiza una operación entre tipos de datos diferentes. Por ejemplo:</p>
        <code>let x = 10 + "20"; // x es "1020" (string)</code><br>
        <code>let y = "10" - 5; // y es 5 (number)</code>
    
        <h2>Conversión explícita</h2>
        <p>Se puede realizar conversión explícita utilizando funciones o operadores específicos:</p>
        <ul>
            <li><code>parseInt()</code> y <code>parseFloat()</code>: Convierten una cadena a un número entero o decimal, respectivamente.  <code>let num1 = parseInt("10"); // num1 es 10</code>  <code>let num2 = parseFloat("10.5"); // num2 es 10.5</code></li>
            <li><code>String()</code>: Convierte un valor a una cadena de texto.</li>
            <li><code>Number()</code>: Convierte un valor a un número.</li>
            <li><code>Boolean()</code>: Convierte un valor a un booleano.</li>
        </ul>
    <h2>Type Coercion</h2>
    <p>La coerción de tipos es la conversión automática o implícita de valores de un tipo de datos a otro. JavaScript es un lenguaje de tipado débil y dinámico, lo que significa que los tipos de datos se convierten automáticamente según sea necesario durante la ejecución del programa. Puede convertir automáticamente los valores de un tipo a otro según sea necesario para completar una operación. Por ejemplo, en una operación de suma donde uno de los operandos es una cadena, JavaScript convertirá el otro operando a cadena y concatenará las cadenas en lugar de sumar los números.</p>  
    <h1>Arrays, Mapas y Conjuntos en JavaScript</h1>

    <h2>Array</h2>
    <p>Un array es una estructura de datos que se utiliza para almacenar una colección de elementos. Puedes inicializar un array con elementos predefinidos o crear un array vacío y agregar elementos a él dinámicamente.</p>
    <p>Ejemplo:</p>
    <pre><code>let numeros = [1, 2, 3, 4, 5];</code></pre>

    <h2>TypedArray</h2>
    <p>TypedArray es un tipo especial de array en JavaScript que proporciona un mecanismo eficiente para trabajar con datos binarios y de tipo específico. A diferencia de los arrays normales, los TypedArray están diseñados para contener elementos de un tipo específico y se utilizan principalmente en operaciones que requieren un acceso rápido a los datos binarios.</p>
    <p>Ejemplo:</p>
    <pre><code>let numeros = new Uint8Array([1, 2, 3, 4, 5]);</code></pre>

    <h2>Map</h2>
    <p>El objeto Map es una estructura de datos que almacena pares clave-valor y mantiene el orden de inserción de las claves. Las claves de un mapa pueden ser de cualquier tipo, incluidos objetos y valores primitivos.</p>
    <p>Ejemplo:</p>
    <pre><code>let mapa = new Map();<br>mapa.set("clave1", "valor1");<br>mapa.set("clave2", "valor2");</code></pre>

    <h2>Set</h2>
    <p>El objeto Set es una estructura de datos que almacena valores únicos de cualquier tipo. Los valores en un conjunto son únicos, lo que significa que no puede haber duplicados en el conjunto.</p>
    <p>Ejemplo:</p>
    <pre><code>let conjunto = new Set();<br>conjunto.add("a");<br>conjunto.add("b");<br>conjunto.add("a"); // "a" ya existe en el conjunto</code></pre>  
    <h2>WeakMap</h2>
    <p>El objeto WeakMap es una colección de pares clave/valor en la que las claves son objetos y los valores pueden ser de cualquier tipo. A diferencia de un Map estándar, las claves en un WeakMap son débiles (weak), lo que significa que no evitan que los objetos utilizados como claves sean eliminados por el recolector de basura si no hay otras referencias a ellos fuera del WeakMap.</p>
    <p>Ejemplo:</p>
    <pre><code>let weakMap = new WeakMap();<br>let key = {};<br>weakMap.set(key, "value");</code></pre>
    <p>Lo que hacen estos weakmap y weakset es que pueden ser borrados por el garbage collector cuando ya no son accesibles o referenciados por ninguna parte del código<br><b>Ejemplo con Weakmap vs Map</b><br><code> john = { name: "John" };<br>
        let weakMap = new WeakMap();<br>
        weakMap.set(john, "...");<br>
        john = null; // overwrite the reference<br>
        // john is removed from memory!<br>
        <br>
        let john = { name: "John" };<br>
        let array = [ john ];<br>
        john = null; // overwrite the reference<br>
        // the object previously referenced by john is stored inside the array<br>
        // therefore it won't be garbage-collected<br>
        // we can get it as array[0]</code></p>
    <h2>WeakSet</h2>
    <p>El objeto WeakSet es una colección de objetos. A diferencia de Set, los objetos en un WeakSet son débiles (weak), lo que significa que si no hay otras referencias a un objeto almacenado en un WeakSet, el recolector de basura puede eliminar el objeto de la memoria.</p>
    <p>Ejemplo:</p>
    <pre><code>let weakSet = new WeakSet();<br>let obj = {};<br>weakSet.add(obj);</code></pre>
    <h2>Comparación de Igualdad Débil (<code>==</code>)</h2>
    <ul>
        <li>JavaScript intenta convertir ambos valores a un tipo común antes de realizar la comparación.</li>
        <li>Si los tipos de los dos valores son diferentes, JavaScript intentará convertir uno o ambos valores para que tengan el mismo tipo antes de realizar la comparación.</li>
        <li>Ejemplo: <code>1 == '1'</code> devuelve <code>true</code> porque JavaScript convierte automáticamente el string <code>'1'</code> en el número <code>1</code> antes de realizar la comparación.</li>
    </ul>
    <h2>Comparación de Igualdad Estricta (<code>===</code>)</h2>
    <ul>
        <li>En una comparación de igualdad estricta, los valores se comparan sin realizar ninguna conversión de tipo.</li>
        <li>Los valores solo se consideran iguales si tienen el mismo valor y el mismo tipo de datos.</li>
        <li>Ejemplo: <code>1 === '1'</code> devuelve <code>false</code> porque los tipos de datos son diferentes (número vs string), incluso si los valores son iguales.</li>
    </ul>
    <p>En general, se recomienda utilizar la comparación de igualdad estricta para las condiciones (<code>===</code>) en lugar de la comparación de igualdad débil (<code>==</code>), ya que la igualdad estricta es más predecible y menos propensa a errores debido a las conversiones automáticas de tipo que realiza JavaScript en la igualdad débil.</p>


    </div>
        <div class="pagina" id="pagina2" style="display: none;">
            <h1>HTML CHEATSHEET</h1>
            <H2>AGRUPADORES</H2>
            <dl>
                <dt>div</dt>
                <dd><div class="divprimero">Agrupador de contenido de toda indole, semanticamente no significa nada, es un bloque que contiene cosas</div></dd>
                <dt>span</dt>
                <dd><span>Agrupador en linea, semanticamente es igual que el div, solo que el div es de bloque y el span es inline </span></dd>
                <H2> AGRUPADORES ESPECIALIZADOS</H2>
                <dt>main</dt>
                <dd>Agrupador especializado que indica el contenido principal</dd>
                <dt>aside</dt>
                <dd>Contenido que va aparte, referencia aparte, contenido bueno de ver que se despega del contenido principal</dd>
                <dt>header</dt>
                <dd>Para hacer las cabeceras de articulo, pagina, etc</dd>
                <dt>footer</dt>
                <dd>Pie de pagina, pie de contenido</dd>
                <dt>nav</dt>
                <dd>Normalmente va adentro de los footer y los header, es la navegacion del sitio, por ejemplo podria ser una lista ordenada dentro de un nav lo cual le indica al user agent que es para navegar al docuemnto o afuera de el</dd>
            </dl>
            <dl>
                <dt>link</dt>
                <dd>Se usa para relaciones entre documentos, por lo general para traer hojas de estilo desde afuera, son hyperlinks que sirven para que el usuario vaya de una pagina a otra, el href brinda la URI, el atributo rel especifica la relacion entre el documento y el link pudiendo ser este stylesheet(hoja de estilo), prefetch que vaya descargando eso de antemano, entre otros. El atributo media es para especificar el dispositrivo donde se mostrara </dd>
                <!-- <link rel="stylesheet" type="text/css" href=""> --> 
                <dt>code</dt>
                <dd>para marcar codigo de un programa, funciona con la eitqueta de preformateado generalmente para respetar espaciado cambio de linea etc <code> if(true)</code></dd>
                <dt>data</dt>
                <dd>vincula un contenido dado con una traduccion legible por una maquina, esto es puramente semantico y no va a renderizarse de ninguna forma, value es a modo id<data value="123">valor</data></dd>
                <dt>kbd</dt>
                <dd>marca el texto que debe introducir el usuario <kbd>por ejemplo deberia introducir esto</kbd></dd>
                <dt>figure</dt>
                <dd> es un elemento de bloque que se usa para imagenes con descrpcion la cual se puede agregar con figcaption, presentacionalmente solo hace salto de linea y pone sangria, figure es en bloque y img es en linea, con</dd>
                <!-- <figure><img src="pato-.jpg"><figcaption>Descripcion</figcaption></figure> -->
                <dt>details</dt>
                <dd>spoiler o detalles expandidos de lo que queriamos hablar, con summary adentro seleccionamos la parte visible que tiene el popup <details><summary>Este es el popup</summary><p>Este es el gran spoiler<p></details></dd>
                <dt>dialog</dt>
                <dd>dialogo de texto o alerta, es como una ventana emergente, si le pongo el atributo open aparece</dd>
                <!-- <dialog open> hola </dialog> -->
                <dt>video</dt>
                <dd>para incrustar videos en un documento html, solo no hace nada, precisa de sus atributos que traen el contenido como src, o controls para que aparezcan los controles, autoplay, etc.</dd>
                <video src="https://www.youtube.com/watch?v=f3dDVtJ2sec&ab_channel=TiagoForte" controls></video>
                <!-- NO TODOS LOS FORMATOS SON ABIERTOS Y COMPATIBLES, EL WEBM ES EL ESTANDAR Y EL OGG ESTA BUENO DE USAR TAMBIEN -->
                <dt>audio</dt>
                <dd>para insertar contenido de audio</dd>
            </dl>
            <dl>
                <dt>picture</dt>
                <dd>Contenedor usado para especificar múltiples elementos source ( pueden ser imágenes o video) y un elemento img contenido en él para proveer versiones de una imágen para diferentes escenarios de dispositivos por tamaño o lo que fuere, siendo la img el escenario en caso de que fallen los sources</dd>
        
                <dt>audio</dt>
                <dd>no usar autoplay.</dd>
        
                <dt>iframe</dt>
                <dd>contexto de navegacion anidado, el cual permite incrustrar otra pagina de html</dd>
        <iframe id="inlineFrameExample"
            title="Inline Frame Example"
            width="300"
            height="200"
            src="https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&layer=mapnik">
        </iframe>
            <div>HOLAAAAAAAAAAAAAAA</div>
<form action="peteco.html" target="_self" method="GET" autocomplete="" novalidate="">
    <label for="hola">Nombre:</label><input type="text" name="hola">
    <input type="password" name="">
    <input type="email" name="">
    <input type="color" name="">
    <input type="date" name="">
    <input type="checkbox" name="">
    <input type="radio" name="">
    <input type="reset" name="">
    <input type="submit" name="">
</form>
    <ol>
        <li>primero</li>
        <li>segundo</li>
        <li>tercero</li>
        <li>cuarto</li>
        <li>quinto</li>
        <button>hola</button>
        <p>pe</p>
    </ol>

    <!-- <p class="especial marco peteco">Crear bla bla bla</p> -->
	<div class="div2"></div>
	<div class="div1"></div>
	<div class="div3"></div>
	<div class="div4"></div>

    <figure>
		<img src="logo.jpeg"> <figcaption>Un pato</figcaption>
	</figure>
	<figure>
		<img src="logo.jpeg"> <figcaption>Un pato</figcaption>
	</figure>
	<figure>
		<img src="logo.jpeg"> <figcaption>Un pato</figcaption>
	</figure>
	<figure>
		<img src="logo.jpeg"> <figcaption>Un pato</figcaption>
	</figure>
        </div>
        <div class="pagina" id="pagina3" style="display: none;">
            <div id="holi"></div>

    <div class="primer">1</div>
	<div class="segundo">2</div>
	<div class="tercero">3</div>
	<div class="cuarto">4</div>

        </div>
        <div id="botones-paginacion">
            <button onclick="mostrarPagina(1)">1</button>
            <button onclick="mostrarPagina(2)">2</button>
            <button onclick="mostrarPagina(3)">3</button>
        </div>

    
   
    
<!-- Las Clases están para poner que un elemento es de un determinado tipo, pero cuando un elemento es de un determinado tipo
se espera de que tenga sub-elementos adentro.
Desde CSS podemos hacer cambios en SVG.

Como incluir estilos: 
-Con el atributo style en el componente html (NO USAR)
-Con la etiqueta <style></style> poniendo el contenido dentro del html (USAR SOLO PARA PAGINAS SIMPLES)
-Hoja de estilo externa (USAR ESTA FORMA)
	-Con el elemento link <link  rel="sylesheet" href=""> (MÁS USADO)
	-Regla at(@) haciendo @import  url("") 
	-a traves de las cabeceras HTTP 
-->


    
</body>
</html>